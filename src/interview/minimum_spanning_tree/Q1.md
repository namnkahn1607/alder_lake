## ðŸ’» Algorithm: Linear Time Bottleneck MST (Camerini's Algorithm)
### âš¡ Insight
__MST Property__: Any _Minimum Spanning Tree_ is also a Bottleneck MST. However, finding the full MST takes $O(ElogE)$ or $O(Elog V)$. We can do better because we only need the value, not the topology. 

__Median Selection__: Instead of sorting edges, we can split the problem space in half by finding the _median_ edge weight (pivot) in linear time.

__Component Contraction__: If the _cheap edges_ aren't enough to connect the graph, we don't throw them away, we **_contract_** the components they form into **_single nodes_**, reducing the problem size for the next step.

### Steps
__Select Pivot__: Find the median weight w of the current set of edges $E$ (using a selection algorithm like QuickSelect).

__Partition__: Split edges into $S_small$ (weight <= pivot) and $S_large$ (weight > pivot).

__Connectivity Check__: Run BFS/DFS using only edges in $S_small$.
__Decision Fork__:
- _If connected_: The bottleneck edge is in $S_small$. Discard S_large entirely. Recurse on $S_small$. 
- _If disconnected_: The bottleneck edge must be in S_large. Identify connected components formed by $S_small$. Contract each component into a single **_super-vertex_**. Map $S_large$ edges to these new vertices (discarding self-loops). Recurse on the modified graph with $S_large$.
- _Base case_: When 1 edge remains or the graph is trivially connected.

### Complexity Analysis
__Time__: $O(E)$. The work done at each step (Partition + BFS/DFS + Contraction) is linear $O(E)$. The problem size halves at each step $(E, E/2, E/4,...)$. The sum of this geometric series is $2E$, which is $O(E)$.
__Space__: $O(E)$ to store edge lists and recursion stack.