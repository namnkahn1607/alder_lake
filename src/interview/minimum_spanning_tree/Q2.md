## ðŸ’» Algorithm: Verifying if an Edge is in an MST
### âš¡ Insight
__Cycle Property__: an edge $e$ is not in any MST if and only if it is the strictly heaviest edge on some cycle in the graph.

__The Inversion__: instead of finding the cycle, we check for the existence of a _cheaper alternative path_ between the edge's endpoints. 

__Threshold Filtering__: if we can connect the endpoints using only edges strictly cheaper than $e$, then $e$ is redundant (suboptimal). If we cannot, $e$ provides critical connectivity at that price point and belongs to the MST.

### ðŸ Steps
__Identify__: let the query edge be $e = (u, v)$ with weight $w_e$.

__Traverse__: initiate a graph traversal (BFS/DFS) starting from vertex $u$.

__Filter__: during traversal, when examining neighbors, ignore any edge with weight $>= w_e$. Only add vertices to the queue/stack if the connecting edge has weight $< w_e$.

__Conclude__:
- If vertex $v$ is reached: a strictly cheaper path exists. Return **False** (Edge is not in MST).
- If the traversal concludes without reaching v: no strictly cheaper path exists. Return **True** (Edge is in MST).

### ðŸ§  Complexity Analysis:
__Time__: $O(V + E)$ in the worst case (standard DFS/BFS traversal).

__Space__: $O(V)$ to store visited array and the recursion stack/queue.